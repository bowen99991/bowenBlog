import { _ as _export_sfc, o as openBlock, c as createElementBlock, b as createTextVNode, d as createStaticVNode, a as createBaseVNode } from "./app-e761162a.js";
const _sfc_main = {};
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<hr><h1 id="javascript" tabindex="-1"><a class="header-anchor" href="#javascript" aria-hidden="true">#</a> Javascript</h1><hr><p>复习:</p><ul><li>JS: ES DOM BOM</li><li>ES 包含：变量、数据、运算符、条件分支语句、循环语句、函数、数组、对象</li><li>JS的对象：自定义对象、内置对象、浏览器对象</li><li>ES对象：自定义对象 内置对象</li></ul><h1 id="一-js简介" tabindex="-1"><a class="header-anchor" href="#一-js简介" aria-hidden="true">#</a> 一，JS简介</h1><hr><p>浏览器分成两部分：渲染引擎和 JS 引擎</p><p>渲染引擎：用来解析HTML与CSS，俗称内核，比如 chrome 浏览器的 blink ，老版本的 webkit JS 引擎：也称为 JS 解释器。 用来读取网页中的JavaScript代码，对其处理后运行，比如 chrome 浏览器的 V8</p><h2 id="_1-1-ecmascript" tabindex="-1"><a class="header-anchor" href="#_1-1-ecmascript" aria-hidden="true">#</a> 1.1 ECMAScript</h2><p>ECMAScript 是由ECMA 国际（ 原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为 JavaScript 或 JScript，但实际上后两者是 ECMAScript 语言的实现和扩展。</p><p>ECMAScript：ECMAScript 规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。</p><h2 id="_1-2-dom-文档对象模型" tabindex="-1"><a class="header-anchor" href="#_1-2-dom-文档对象模型" aria-hidden="true">#</a> 1.2 DOM-文档对象模型</h2><p>文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）。</p><h2 id="_1-3-bom-浏览器对象模型" tabindex="-1"><a class="header-anchor" href="#_1-3-bom-浏览器对象模型" aria-hidden="true">#</a> 1.3 BOM-浏览器对象模型</h2><p>BOM (Browser Object Model，简称BOM) 是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。</p><h1 id="二-变量" tabindex="-1"><a class="header-anchor" href="#二-变量" aria-hidden="true">#</a> 二，变量</h1><hr><p>变量在内存中的存储 本质：变量是程序在内存中申请的一块用来存放数据的空间。</p><p>声明变量并赋值我们称之为变量的初始化</p><h2 id="_2-1-命名规范" tabindex="-1"><a class="header-anchor" href="#_2-1-命名规范" aria-hidden="true">#</a> 2.1 命名规范</h2><p>由字母(A-Za-z)、数字(0-9)、下划线(_)、美元符号( $ )组成，如：usrAge, num01, _name 严格区分大小写。var app; 和 var App; 是两个变量 不能 以数字开头。 18age 是错误的 不能 是关键字、保留字。例如：var、for、while 变量名必须有意义。 MMD BBD nl → age 遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。 myFirstName</p><h1 id="三-数据类型" tabindex="-1"><a class="header-anchor" href="#三-数据类型" aria-hidden="true">#</a> 三，数据类型</h1><hr><p>简单数据类型和复杂数据类型</p><p><strong>JS的严格模式</strong></p><p><em>严格模式可以提高代码的质量、可维护性和安全性。它是一种良好的编码实践，推荐在所有的 JavaScript 代码中使用</em></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>  <span class="token comment">// 前提： idea 需要设置支持es6语法</span>\n    <span class="token comment">// &#39;use strict&#39;;    // 开启严格审查模式</span>\n\n    <span class="token comment">// i = 1   // 未被定义</span>\n    <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;aasdasdad&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;adsadasd&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">&#39;hello world&#39;</span>\n    <span class="token keyword">let</span> arr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&#39;,&#39;</span><span class="token punctuation">)</span>  <span class="token comment">// 字符串转为数组 split()</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-1简单数据类型" tabindex="-1"><a class="header-anchor" href="#_3-1简单数据类型" aria-hidden="true">#</a> 3.1简单数据类型</h2><p>简单数据类型存放到栈里面</p><ul><li>Number</li><li>Boolean</li><li>String</li><li>Undefined</li><li>Null</li></ul><h3 id="_3-1-1-数字型-number" tabindex="-1"><a class="header-anchor" href="#_3-1-1-数字型-number" aria-hidden="true">#</a> 3.1.1 数字型 Number</h3><p>3.1.1.1 数字型范围</p><p>alert(Number.MAX_VALUE); // 1.7976931348623157e+308 alert(Number.MIN_VALUE); // 5e-324</p><p>最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308 最小值：Number.MIN_VALUE，这个值为：5e-32</p><p>3.1.1.2 数字型三个特殊值</p><p>alert(Infinity); // Infinity alert(-Infinity); // -Infinity alert(NaN); // NaN</p><p>Infinity：代表无穷大，大于任何数值 -Infinity：代表无穷小，小于任何数值 NaN ：Not a number，代表一个非数值</p><p>3.1.1.3 isNaN()</p><p>用来判断一个变量是否为非数字的类型，返回 true 或者 false</p><p>3.1.2 字符串型 String</p><p>HTML 标签里面的属性使用的是双引号，JS 更推荐使用单引号。</p><p>根据位置返回字符:</p><p>根据字符返回位置:</p><p>字符串操作方法:</p><p>其他方法：</p><p>toUpperCase() //转换大写 toLowerCase() //转换小写 replace() //用于在字符串中用一些字符替换另一些字符 split() //用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组。</p><h3 id="_3-1-3-布尔型-boolean" tabindex="-1"><a class="header-anchor" href="#_3-1-3-布尔型-boolean" aria-hidden="true">#</a> 3.1.3 布尔型 Boolean</h3><p>布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0</p><h3 id="_3-1-4-undefined-和-null" tabindex="-1"><a class="header-anchor" href="#_3-1-4-undefined-和-null" aria-hidden="true">#</a> 3.1.4 Undefined 和 Null</h3><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">//undefined</span>\n<span class="token keyword">var</span> variable<span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>variable<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// undefined</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;你好&#39;</span> <span class="token operator">+</span> variable<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 你好undefined</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">11</span> <span class="token operator">+</span> variable<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// NaN</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">+</span> variable<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//  NaN</span>\n\n\n<span class="token comment">//null</span>\n<span class="token keyword">var</span> vari <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;你好&#39;</span> <span class="token operator">+</span> vari<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 你好null</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">11</span> <span class="token operator">+</span> vari<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 11</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">+</span> vari<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//  1</span>\n\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-1-5-获取检测变量的数据类型" tabindex="-1"><a class="header-anchor" href="#_3-1-5-获取检测变量的数据类型" aria-hidden="true">#</a> 3.1.5 获取检测变量的数据类型</h3><p>typeof 可用来获取检测变量的数据类型</p><p>3.1.6 数据类型转换</p><p>3.1.6.1 转换为字符串</p><p>3.1.6.2 转换为数字型</p><p>隐式转换是我们在进行算数运算的时候，JS 自动转换了数据类型</p><p>3.1.6.3 转换为布尔型</p><p>代表空、否定的值会被转换为 false ，如 ‘’、0、NaN、null、undefined 其余值都会被转换为 true</p><hr><h2 id="_3-2-复杂类型-引用类型" tabindex="-1"><a class="header-anchor" href="#_3-2-复杂类型-引用类型" aria-hidden="true">#</a> 3.2 复杂类型(引用类型)</h2><p>复杂数据类型，在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型 通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等 复杂数据类型存放到堆里面</p><hr><h1 id="四-关键字和保留字" tabindex="-1"><a class="header-anchor" href="#四-关键字和保留字" aria-hidden="true">#</a> 四，关键字和保留字</h1><hr><h2 id="_4-1-关键字" tabindex="-1"><a class="header-anchor" href="#_4-1-关键字" aria-hidden="true">#</a> 4.1 关键字</h2><p>关键字：是指 JS本身已经使用了的字，不能再用它们充当变量名、方法名。 包括：break、case、catch、continue、default、delete、do、else、finally、for、function、if、in、instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with 等。</p><h2 id="_4-2-保留字" tabindex="-1"><a class="header-anchor" href="#_4-2-保留字" aria-hidden="true">#</a> 4.2 保留字</h2><p>保留字：实际上就是预留的“关键字”，意思是现在虽然还不是关键字，但是未来可能会成为关键字，同样不能使用它们当变量名或方法名。 包括：boolean、byte、char、class、const、debugger、double、enum、export、extends、fimal、float、goto、implements、import、int、interface、long、mative、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile 等。 注意：如果将保留字用作变量名或函数名，那么除非将来的浏览器实现了该保留字，否则很可能收不到任何错误消息。当浏览器将其实现后，该单词将被看做关键字，如此将出现关键字错误。</p><h1 id="五-运算符" tabindex="-1"><a class="header-anchor" href="#五-运算符" aria-hidden="true">#</a> 五， 运算符</h1><hr><p>JavaScript中常用的运算符有：</p><ul><li>算数运算符</li><li>递增和递减运算符</li><li>比较运算符</li><li>逻辑运算符</li><li>赋值运算符</li></ul><hr><h2 id="_5-1-算数运算符" tabindex="-1"><a class="header-anchor" href="#_5-1-算数运算符" aria-hidden="true">#</a> 5.1 算数运算符</h2><ul><li><ul><li><ul><li>/ %</li></ul></li></ul></li></ul><p>浮点数的精度问题</p><p>var result = 0.1 + 0.2; // 结果不是 0.3，而是：0.30000000000000004 console.log(0.07 * 100); // 结果不是 7， 而是：7.000000000000001 1 2 注：不要直接判断两个浮点数是否相等</p><p>5.2 递增和递减运算符 如果需要反复给数字变量添加或减去1，可以使用递增（++）和递减（ – ）运算符来完成。 ++num 前置递增：先自加，后返回值 num++：先返回原值，后自加</p><h2 id="_5-3-比较运算符" tabindex="-1"><a class="header-anchor" href="#_5-3-比较运算符" aria-hidden="true">#</a> 5.3 比较运算符</h2><p>&lt; &gt; &gt;= &lt;= == != === !==</p><h2 id="_5-4-逻辑运算符" tabindex="-1"><a class="header-anchor" href="#_5-4-逻辑运算符" aria-hidden="true">#</a> 5.4 逻辑运算符</h2><p>逻辑与&amp;&amp; 逻辑或|| 取反符!</p><h2 id="_5-5-赋值运算符" tabindex="-1"><a class="header-anchor" href="#_5-5-赋值运算符" aria-hidden="true">#</a> 5.5 赋值运算符</h2><p>= += -= *= /= %=</p><h2 id="_5-6-运算符优先级" tabindex="-1"><a class="header-anchor" href="#_5-6-运算符优先级" aria-hidden="true">#</a> 5.6 运算符优先级</h2><p>一元运算符里面的逻辑非优先级很高 逻辑与比逻辑或优先级高</p><hr><h1 id="六-流程控制" tabindex="-1"><a class="header-anchor" href="#六-流程控制" aria-hidden="true">#</a> 六， 流程控制</h1><hr><p>流程控制主要有三种结构，分别是顺序结构、分支结构和循环结构，这三种结构代表三种代码执行的顺序。</p><h2 id="_6-1-顺序流程控制" tabindex="-1"><a class="header-anchor" href="#_6-1-顺序流程控制" aria-hidden="true">#</a> 6.1 顺序流程控制</h2><p>程序会按照代码的先后顺序，依次执行</p><h2 id="_6-2-分支流程控制" tabindex="-1"><a class="header-anchor" href="#_6-2-分支流程控制" aria-hidden="true">#</a> 6.2 分支流程控制</h2><p>JS 语言提供了两种分支结构语句</p><p>if 语句 switch 语句</p><h3 id="_6-2-1-if" tabindex="-1"><a class="header-anchor" href="#_6-2-1-if" aria-hidden="true">#</a> 6.2.1 if</h3><p>if (条件表达式1) { 语句1; } else if (条件表达式2) { 语句2; } else if (条件表达式3) { 语句3; .... } else { // 上述条件都不成立执行此处代码 } 1 2 3 4 5 6 7 8 9 10</p><h3 id="_6-2-2-switch" tabindex="-1"><a class="header-anchor" href="#_6-2-2-switch" aria-hidden="true">#</a> 6.2.2 switch</h3><p>switch( 表达式 ){ case value1: // 表达式 等于 value1 时要执行的代码 break; case value2: // 表达式 等于 value2 时要执行的代码 break; default: // 表达式 不等于任何一个 value 时要执行的代码 } 1 2 3 4 5 6 7 8 9 10 关键字 switch 后面括号内可以是表达式或值， 通常是一个变量 注： 执行case 里面的语句时，如果没有break，则继续执行下一个case里面的语句。</p><h3 id="_6-2-3-三元表达式" tabindex="-1"><a class="header-anchor" href="#_6-2-3-三元表达式" aria-hidden="true">#</a> 6.2.3 三元表达式</h3><p>表达式1 ? 表达式2 : 表达式3; 1 如果表达式1为 true ，则返回表达式2的值，如果表达式1为 false，则返回表达式3的值</p><h2 id="_6-3-循环" tabindex="-1"><a class="header-anchor" href="#_6-3-循环" aria-hidden="true">#</a> 6.3 循环</h2><p>在Js 中，主要有三种类型的循环语句：</p><p>for 循环 while 循环 do…while 循环</p><h3 id="_6-3-1-for-循环" tabindex="-1"><a class="header-anchor" href="#_6-3-1-for-循环" aria-hidden="true">#</a> 6.3.1 for 循环</h3><p>for(初始化变量; 条件表达式; 操作表达式){ //循环体语句 } 1 2 3</p><h3 id="_6-3-2-while循环" tabindex="-1"><a class="header-anchor" href="#_6-3-2-while循环" aria-hidden="true">#</a> 6.3.2 while循环</h3><p>while (条件表达式) { // 循环体代码 } 1 2 3 使用 while 循环时一定要注意，它必须要有退出条件，否则会成为死循环</p><h3 id="_6-3-3-do-while-循环" tabindex="-1"><a class="header-anchor" href="#_6-3-3-do-while-循环" aria-hidden="true">#</a> 6.3.3 do while 循环</h3><p>do { // 循环体代码 - 条件表达式为 true 时重复执行循环体代码 } while(条件表达式); 1 2 3 先再执行循环体，再判断，我们会发现 do…while 循环语句至少会执行一次循环体代码</p><h3 id="_6-3-4-continue-break" tabindex="-1"><a class="header-anchor" href="#_6-3-4-continue-break" aria-hidden="true">#</a> 6.3.4 continue break</h3><p>continue: 用于立即跳出本次循环，继续下一次循环。 break: 用于立即跳出整个循环（循环结束）。</p><h1 id="七-数组" tabindex="-1"><a class="header-anchor" href="#七-数组" aria-hidden="true">#</a> 七，数组</h1><hr><p>JS 中创建数组有两种方式：</p><p>利用 new 创建数组 利用数组字面量创建数组 var 数组名 = new Array(); var 数组名 = []; 1 2 7.1 检测是否为数组 instanceof 运算符，可以判断一个对象是否属于某种类型 Array.isArray()用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法</p><p>var arr = [1, 23]; var obj = {}; console.log(arr instanceof Array); // true console.log(obj instanceof Array); // false console.log(Array.isArray(arr)); // true console.log(Array.isArray(obj)); // false 1 2 3 4 5 6</p><h2 id="_7-2-添加删除数组元素的方法" tabindex="-1"><a class="header-anchor" href="#_7-2-添加删除数组元素的方法" aria-hidden="true">#</a> 7.2 添加删除数组元素的方法</h2><h2 id="_7-3-数组排序" tabindex="-1"><a class="header-anchor" href="#_7-3-数组排序" aria-hidden="true">#</a> 7.3 数组排序</h2><h2 id="_7-4-数组索引方法" tabindex="-1"><a class="header-anchor" href="#_7-4-数组索引方法" aria-hidden="true">#</a> 7.4 数组索引方法</h2><h2 id="_7-5-数组转换为字符串" tabindex="-1"><a class="header-anchor" href="#_7-5-数组转换为字符串" aria-hidden="true">#</a> 7.5 数组转换为字符串</h2><h2 id="_7-6-其他方法" tabindex="-1"><a class="header-anchor" href="#_7-6-其他方法" aria-hidden="true">#</a> 7.6 其他方法</h2><h1 id="八-函数" tabindex="-1"><a class="header-anchor" href="#八-函数" aria-hidden="true">#</a> 八，函数</h1><hr><p>概念：封装了一段可被重复调用执行的代码块。通过此代码块可以实现大量代码的重复使用。</p><p>// 声明函数 function 函数名() { //函数体代码 }</p><p>// 调用函数 函数名(); 1 2 3 4 5 6 7 注：声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。</p><p>break ：结束当前的循环体（如 for、while） continue ：跳出本次循环，继续执行下次循环（如 for、while） return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码</p><h2 id="_8-1-arguments的使用" tabindex="-1"><a class="header-anchor" href="#_8-1-arguments的使用" aria-hidden="true">#</a> 8.1 arguments的使用</h2><p>当我们不确定有多少个参数传递的时候，可以用 arguments 来获取。在 JavaScript 中，arguments 实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。</p><p>arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：</p><p>具有 length 属性 按索引方式储存数据 不具有数组的 push , pop 等方法</p><h1 id="九-对象" tabindex="-1"><a class="header-anchor" href="#九-对象" aria-hidden="true">#</a> 九， 对象</h1><hr><p>在 JavaScript 中，现阶段我们可以采用三种方式创建对象（object）：</p><p>利用字面量创建对象 利用 new Object 创建对象 利用构造函数创建对象</p><h2 id="_9-1-利用字面量创建对象" tabindex="-1"><a class="header-anchor" href="#_9-1-利用字面量创建对象" aria-hidden="true">#</a> 9.1 利用字面量创建对象</h2><p>//创建 var star = { name : &#39;zhangsan&#39;, age : 18, sex : &#39;男&#39;, sayHi : function(){ alert(&#39;大家好啊~&#39;); } };</p><p>//调用 console.log(star.name) // 调用名字属性 console.log(star[&#39;name&#39;]) // 调用名字属性 star.sayHi(); // 调用 sayHi 方法,注意，一定不要忘记带后面的括号</p><h2 id="_9-2-利用new-object创建对象" tabindex="-1"><a class="header-anchor" href="#_9-2-利用new-object创建对象" aria-hidden="true">#</a> 9.2 利用new Object创建对象</h2><p>var andy = new Obect(); andy.name = &#39;zhangsan&#39;; andy.age = 18; andy.sex = &#39;男&#39;; andy.sayHi = function(){ alert(&#39;大家好啊~&#39;); } 1 2 3 4 5 6 7</p><h2 id="_9-3-利用构造函数创建对象" tabindex="-1"><a class="header-anchor" href="#_9-3-利用构造函数创建对象" aria-hidden="true">#</a> 9.3 利用构造函数创建对象</h2><p>构造函数 ：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</p><p>在 js 中，使用构造函数要时要注意以下两点：</p><p>构造函数用于创建某一类对象，其首字母要大写 构造函数要和 new 一起使用才有意义 function Person(name, age, sex) { this.name = name; this.age = age; this.sex = sex; this.sayHi = function() { alert(&#39;我的名字叫：&#39; + this.name + &#39;，年龄：&#39; + this.age + &#39;，性别：&#39; + this.sex); } } var bigbai = new Person(&#39;大白&#39;, 100, &#39;男&#39;); var smallbai = new Person(&#39;小白&#39;, 21, &#39;男&#39;); console.log(bigbai.name); console.log(smallbai.name); 1 2 3 4 5 6 7 8 9 10 11 12 注意：</p><p>构造函数约定首字母大写。 函数内的属性和方法前面需要添加 this ，表示当前对象的属性和方法。 构造函数中不需要 return 返回结果。 当我们创建对象的时候，必须用 new 来调用构造函数。</p><h2 id="_9-4-遍历对象属性" tabindex="-1"><a class="header-anchor" href="#_9-4-遍历对象属性" aria-hidden="true">#</a> 9.4 遍历对象属性</h2><p>for…in 语句用于对数组或者对象的属性进行循环操作。</p><p>for (var k in obj) { console.log(k); // 这里的 k 是属性名 console.log(obj[k]); // 这里的 obj[k] 是属性值 }</p><h1 id="十-内置对象" tabindex="-1"><a class="header-anchor" href="#十-内置对象" aria-hidden="true">#</a> 十， 内置对象</h1><hr><p>内置对象就是指 JS 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能（属性和方法） JavaScript 提供了多个内置对象：Math、 Date 、Array、String等</p><h2 id="_10-1-math对象" tabindex="-1"><a class="header-anchor" href="#_10-1-math对象" aria-hidden="true">#</a> 10.1 Math对象</h2><p>Math 对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用 Math 中的成员。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>Math<span class="token punctuation">.</span><span class="token constant">PI</span>		  <span class="token comment">// 圆周率</span>\nMath<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 向下取整</span>\nMath<span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">// 向上取整</span>\nMath<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 四舍五入版 就近取整   注意 -3.5   结果是  -3 </span>\nMath<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token punctuation">)</span>	  <span class="token comment">// 绝对值</span>\nMath<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span>	 <span class="token comment">// 求最大和最小值</span>\n\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_10-1-1-随机数方法-random" tabindex="-1"><a class="header-anchor" href="#_10-1-1-随机数方法-random" aria-hidden="true">#</a> 10.1.1 随机数方法 random()</h3><p>random() 方法可以随机返回一个小数，其取值范围是 [0，1)，左闭右开 0 &lt;= x &lt; 1</p><p>得到一个两数之间的随机整数，包括两个数在内</p><p>function getRandom(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }</p><h2 id="_10-2-日期对象" tabindex="-1"><a class="header-anchor" href="#_10-2-日期对象" aria-hidden="true">#</a> 10.2 日期对象</h2><p>var now = new Date(); 1</p><p>如果括号里面有时间，就返回参数里面的时间。例如日期格式字符串为‘2019-5-1’，可以写成new Date(‘2019-5-1’) 或者 new Date(‘2019/5/1’)</p><p>日期格式化：</p><p>获取日期的总的毫秒形式：</p><p>// 实例化Date对象 var now = new Date(); // 1. 用于获取对象的原始值 console.log(date.valueOf()) console.log(date.getTime()) // 2. 简单写可以这么做 var now = + new Date(); // 3. HTML5中提供的方法，有兼容性问题 var now = Date.now();</p><h1 id="十一-操作dom" tabindex="-1"><a class="header-anchor" href="#十一-操作dom" aria-hidden="true">#</a> 十一，操作DOM</h1><hr><h2 id="_11-1-dom简介" tabindex="-1"><a class="header-anchor" href="#_11-1-dom简介" aria-hidden="true">#</a> 11.1 DOM简介</h2><p>文档：一个页面就是一个文档，DOM 中使用 document 表示 元素：页面中的所有标签都是元素，DOM 中使用 element 表示 节点：网页中的所有内容都是节点（标签、属性、文本、注释等），DOM 中使用 node 表示 DOM 把以上内容都看做是对象</p><h2 id="_11-2-获取页面元素" tabindex="-1"><a class="header-anchor" href="#_11-2-获取页面元素" aria-hidden="true">#</a> 11.2 获取页面元素</h2><p>获取页面中的元素可以使用以下几种方式:</p><p>根据 ID 获取 根据标签名获取 通过 HTML5 新增的方法获取 特殊元素获取</p><h3 id="_11-2-1-根据id获取" tabindex="-1"><a class="header-anchor" href="#_11-2-1-根据id获取" aria-hidden="true">#</a> 11.2.1 根据id获取</h3><p>使用 getElementById() 方法可以获取带有 ID 的元素对象。</p><p>document.getElementById(&#39;id&#39;); 1 使用 console.dir() 可以打印我们获取的元素对象，更好的查看对象里面的属性和方法。</p><h3 id="_11-2-2-根据标签名获取" tabindex="-1"><a class="header-anchor" href="#_11-2-2-根据标签名获取" aria-hidden="true">#</a> 11.2.2 根据标签名获取</h3><p>使用 getElementsByTagName() 方法可以返回带有指定标签名的对象的集合。</p><p>document.getElementsByTagName(&#39;标签名&#39;); 1 注意：</p><p>因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历。 得到元素对象是动态的 如果获取不到元素,则返回为空的伪数组(因为获取不到对象) 还可以获取某个元素(父元素)内部所有指定标签名的子元素.</p><p>element.getElementsByTagName(&#39;标签名&#39;); 1 注意：父元素必须是单个对象(必须指明是哪一个元素对象). 获取的时候不包括父元素自己。</p><h3 id="_11-2-3-通过-html5-新增的方法获取" tabindex="-1"><a class="header-anchor" href="#_11-2-3-通过-html5-新增的方法获取" aria-hidden="true">#</a> 11.2.3 通过 HTML5 新增的方法获取</h3><ol><li>document.getElementsByClassName(‘类名’)；// 根据类名返回元素对象集合</li><li>document.querySelector(&#39;选择器&#39;); // 根据指定选择器返回第一个元素对象</li><li>document.querySelectorAll(&#39;选择器&#39;); // 根据指定选择器返回 1 2 3 注意： querySelector 和 querySelectorAll里面的选择器需要加符号,比如:document.querySelector(‘#nav’);</li></ol><h3 id="_11-2-4-classlist-属性" tabindex="-1"><a class="header-anchor" href="#_11-2-4-classlist-属性" aria-hidden="true">#</a> 11.2.4 classList 属性</h3><p>classList属性是HTML5新增的一个属性，返回元素的类名。但是ie10以上版本支持。 该属性用于在元素中添加，移除及切换 CSS 类。</p><p>11.2.4.1 添加类</p><p>element.classList.add(’类名’):</p><p>11.2.4.2 移除类</p><p>element.classList.add(’类名’):</p><p>11.2.4.3 切换类</p><p>element.classList.toggle(’类名’):</p><p>注意：以上方法里面，所有类名都不带点</p><h3 id="_11-2-5-获取特殊元素-body-html" tabindex="-1"><a class="header-anchor" href="#_11-2-5-获取特殊元素-body-html" aria-hidden="true">#</a> 11.2.5 获取特殊元素（body，html）</h3><p>doucumnet.body // 返回body元素对象 document.documentElement // 返回html元素对象</p><h2 id="_11-3-事件" tabindex="-1"><a class="header-anchor" href="#_11-3-事件" aria-hidden="true">#</a> 11.3 事件</h2><h3 id="_11-3-1-常见的鼠标事件" tabindex="-1"><a class="header-anchor" href="#_11-3-1-常见的鼠标事件" aria-hidden="true">#</a> 11.3.1 常见的鼠标事件</h3><p>禁止鼠标右键菜单 contextmenu主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单 document.addEventListener(&#39;contextmenu&#39;, function(e) { e.preventDefault(); }) 1 2 3 禁止鼠标选中（selectstart 开始选中） document.addEventListener(&#39;selectstart&#39;, function(e) { e.preventDefault(); }) 1 2 3 mouseenter 和mouseover的区别 当鼠标移动到元素上时就会触发 mouseenter 事件 类似 mouseover，它们两者之间的差别是 mouseover 鼠标经过自身盒子会触发，经过子盒子还会触发。 mouseenter 只会经过自身盒子触发 之所以这样，就是因为mouseenter不会冒泡 跟mouseenter搭配 鼠标离开 mouseleave 同样不会冒泡</p><h3 id="_11-3-2-常用的键盘事件" tabindex="-1"><a class="header-anchor" href="#_11-3-2-常用的键盘事件" aria-hidden="true">#</a> 11.3.2 常用的键盘事件</h3><p>注意： onkeydown 和 onkeyup 不区分字母大小写，onkeypress 区分字母大小写。 在实际开发中，更多的使用keydown和keyup， 它能识别所有的键（包括功能键） Keypress 不识别功能键，但是keyCode属性能区分大小写，返回不同的ASCII值</p><h3 id="_11-3-3-注册事件-绑定事件" tabindex="-1"><a class="header-anchor" href="#_11-3-3-注册事件-绑定事件" aria-hidden="true">#</a> 11.3.3 注册事件（绑定事件）</h3><p>给元素添加事件，称为注册事件或者绑定事件。 注册事件有两种方式：传统方式和方法监听注册方式</p><h4 id="_11-3-3-1-addeventlistener-事件监听方式" tabindex="-1"><a class="header-anchor" href="#_11-3-3-1-addeventlistener-事件监听方式" aria-hidden="true">#</a> 11.3.3.1 addEventListener 事件监听方式</h4><p>eventTarget.addEventListener(type, listener[, useCapture])<br> 1 将指定的监听器注册到 eventTarget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数。</p><p>type：事件类型字符串，比如 click 、mouseover ，注意这里不要带 on listener：事件处理函数，事件发生时，会调用该监听函数 useCapture：可选参数，是一个布尔值，默认是 false。</p><h4 id="_11-3-3-2-attachevent-事件监听方式" tabindex="-1"><a class="header-anchor" href="#_11-3-3-2-attachevent-事件监听方式" aria-hidden="true">#</a> 11.3.3.2 attachEvent 事件监听方式</h4><p>eventTarget.attachEvent(eventNameWithOn, callback) 1 将指定的监听器注册到 eventTarget（目标对象） 上，当该对象触发指定的事件时，指定的回调函数就会被执行。</p><p>eventNameWithOn：事件类型字符串，比如 onclick 、onmouseover ，这里要带 on callback： 事件处理函数，当目标触发事件时回调函数被调用 注意：IE8 及早期版本支持</p><h3 id="_11-3-4-删除事件-解绑事件" tabindex="-1"><a class="header-anchor" href="#_11-3-4-删除事件-解绑事件" aria-hidden="true">#</a> 11.3.4 删除事件（解绑事件）</h3><ol><li><p>传统注册方式 eventTarget.onclick = null;</p></li><li><p>方法监听注册方式 ① eventTarget.removeEventListener(type, listener[, useCapture]); ② eventTarget.detachEvent(eventNameWithOn, callback); 1 2 3 4 5 6</p></li></ol><p>11.3.5 DOM 事件流</p><p>事件流描述的是从页面中接收事件的顺序。 事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即 DOM 事件流。 比如我们给一个div 注册了点击事件： DOM 事件流分为3个阶段：</p><p>捕获阶段 当前目标阶段 冒泡阶段</p><p>事件冒泡： IE 最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点的过程。 事件捕获： 网景最早提出，由 DOM 最顶层节点开始，然后逐级向下传播到到最具体的元素接收的过程。</p><p>事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即 DOM 事件流。 注意：</p><p>JS 代码中只能执行捕获或者冒泡其中的一个阶段。 onclick 和 attachEvent 只能得到冒泡阶段。 addEventListener(type, listener[, useCapture])第三个参数如果是 true，表示在事件捕获阶段调用事件处理程序；如果是 false（不写默认就是false），表示在事件冒泡阶段调用事件处理程序。 实际开发中我们很少使用事件捕获，我们更关注事件冒泡。 有些事件是没有冒泡的，比如 onblur、onfocus、onmouseenter、onmouseleave 事件冒泡有时候会带来麻烦，有时候又会帮助很巧妙的做某些事件。</p><p>11.3.6</p><p>eventTarget.onclick = function(event) {} eventTarget.addEventListener(&#39;click&#39;, function(event) {}） // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt 1 2 3 官方解释：event 对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态。</p><p>11.3.6.1 事件对象本身的获取存在兼容问题： 标准浏览器中是浏览器给方法传递的参数，只需要定义形参 e 就可以获取到。 在 IE6~8 中，浏览器不会给方法传递参数，如果需要的话，需要到 window.event 中获取查找。 解决: e = e || window.event;</p><p>11.3.6.2 事件对象的常见属性和方法 e.target 和 this 的区别：</p><p>this 是事件绑定的元素， 这个函数的调用者（绑定这个事件的元素） e.target 是事件触发的元素。</p><h3 id="_11-3-7-阻止事件冒泡" tabindex="-1"><a class="header-anchor" href="#_11-3-7-阻止事件冒泡" aria-hidden="true">#</a> 11.3.7 阻止事件冒泡</h3><p>事件冒泡：开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点。 事件冒泡本身的特性，会带来的坏处，也会带来的好处</p><p>标准写法：利用事件对象里面的 stopPropagation()方法 e.stopPropagation() 非标准写法：IE 6-8 利用事件对象 cancelBubble 属性 e.cancelBubble = true; 11.3.8 事件委托（代理、委派） 事件冒泡本身的特性，会带来的坏处，也会带来的好处</p><p>例子：</p><ul><li>点击出现对话框</li><li>点击出现对话框</li><li>点击出现对话框</li><li>点击出现对话框</li><li>点击出现对话框</li></ul><p>//点击每个 li 都会弹出对话框，以前需要给每个 li 注册事件，是非常辛苦的，而且访问 DOM 的次数越多，这就会延长整个页面的交互就绪时间。 1 2 3 4 5 6 7 8 9 10 事件委托 事件委托也称为事件代理， 在 jQuery 里面称为事件委派。 事件委托的原理 不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点。 以上案例：给 ul 注册点击事件，然后利用事件对象的 target 来找到当前点击的 li，因为点击 li，事件会冒泡到 ul 上， ul 有注册事件，就会触发事件监听器。 事件委托的作用 我们只操作了一次 DOM ，提高了程序的性能。</p><h2 id="_11-4-操作元素" tabindex="-1"><a class="header-anchor" href="#_11-4-操作元素" aria-hidden="true">#</a> 11.4 操作元素</h2><p>JavaScript 的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容 、属性等。注意以下都是属性</p><h3 id="_11-4-1-改变元素内容" tabindex="-1"><a class="header-anchor" href="#_11-4-1-改变元素内容" aria-hidden="true">#</a> 11.4.1 改变元素内容</h3><p>// 从起始位置到终止位置的内容, 但它去除 html 标签， 同时空格和换行也会去掉 element.innerText</p><p>//起始位置到终止位置的全部内容，包括 html 标签，同时保留空格和换行 element.innerHTML</p><p>src、href、id、alt、title等 1 2 3 4 5 6 7 11.4.2 表单元素的属性操作 利用 DOM 可以操作如下表单元素的属性： type、value、checked、selected、disabled</p><p>11.4.3 样式属性操作 我们可以通过 JS 修改元素的大小、颜色、位置等样式。</p><ol><li>element.style 行内样式操作</li><li>element.className 类名样式操作 1 2 注意：</li></ol><p>JS 里面的样式采取驼峰命名法 比如 fontSize、 backgroundColor JS 修改 style 样式操作，产生的是行内样式，CSS 权重比较高 className 会直接更改元素的类名，会覆盖原先的类名。 11.4.4 小结</p><h3 id="_11-4-5-自定义属性的操作" tabindex="-1"><a class="header-anchor" href="#_11-4-5-自定义属性的操作" aria-hidden="true">#</a> 11.4.5 自定义属性的操作</h3><p>获取属性值： element.属性 获取属性值。（元素本身自带的属性） element.getAttribute(‘属性’); 主要获得自定义的属性 （标准）自定义的属性</p><p>设置属性值: element.属性 = ‘值’ 设置内置属性值。 element.setAttribute(‘属性’, ‘值’); 主要设置自定义的属性 （标准）</p><p>移除属性 element.removeAttribute(‘属性’);</p><p>11.4.6 H5自定义属性 自定义属性目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。 自定义属性获取是通过getAttribute(‘属性’) 获取。 但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性。</p><p>11.4.6.1 设置H5自定义属性 H5规定自定义属性data-开头做为属性名并且赋值。 比如 <div data-index="“1”"></div> 或者使用 JS 设置 element.setAttribute(‘data-index’, 2)</p><p>11.4.6.2 获取H5自定义属性 兼容性获取 element.getAttribute(‘data-index’); H5新增 element.dataset.index 或者 element.dataset[‘index’] ie 11才开始支持</p><h2 id="_11-5-操作节点" tabindex="-1"><a class="header-anchor" href="#_11-5-操作节点" aria-hidden="true">#</a> 11.5 操作节点</h2><h3 id="_11-5-1-父级节点" tabindex="-1"><a class="header-anchor" href="#_11-5-1-父级节点" aria-hidden="true">#</a> 11.5.1 父级节点</h3><p>node.parentNode parentNode 属性可返回某节点的父节点，注意是最近的一个父节点 如果指定的节点没有父节点则返回 null</p><p>11.5.2 子节点 parentNode.childNodes（标准） <code>返回包含指定节点的子节点的集合，该集合为即时更新的集合。 注意：返回值里面包含了所有的子节点，包括元素节点，文本节点等。 如果只想要获得里面的元素节点，则需要专门处理。 所以一般不提倡使用childNodes</code></p><p>parentNode.children（非标准） <code>是一个只读属性，返回所有的子元素节点。它只返回子元素节点，其余节点不返回。 虽然children 是一个非标准，但是得到了各个浏览器的支持，因此可以放心使用</code> 1 2 3 4 5 6 7 8 parentNode.firstChild <code>返回第一个子节点，找不到则返回null。包含所有的节点（包含后代）。</code></p><p>parentNode.lastChild <code>返回最后一个子节点，找不到则返回null。包含所有的节点（包含后代）。</code> 1 2 3 4 5 parentNode.firstElementChild <code>返回第一个子元素节点，找不到则返回null。</code></p><p>parentNode.lastElementChild <code>返回最后一个子元素节点，找不到则返回null。</code></p><p>注意：这两个方法有兼容性问题，IE9 以上才支持。 1 2 3 4 5 6 7 实际开发中，firstChild 和 lastChild 包含其他节点，操作不方便，而 firstElementChild 和 lastElementChild 又有兼容性问题，那如何获取第一个子元素节点或最后一个子元素节点呢？ 解决方案： 如果想要第一个子元素节点，可以使用 parentNode.chilren[0] 如果想要最后一个子元素节点，可以使用 parentNode.chilren[parentNode.chilren.length - 1]</p><p>11.5.3 兄弟节点 node.nextSibling <code>返回当前元素的下一个兄弟元素节点，找不到则返回null。同样，也是包含所有的节点。</code></p><p>node.previousSibling <code>返回当前元素上一个兄弟元素节点，找不到则返回null。同样，也是包含所有的节点。</code> 1 2 3 4 5 node.nextElementSibling <code>返回当前元素下一个兄弟元素节点，找不到则返回null。</code></p><p>node.previousElementSibling <code>返回当前元素上一个兄弟节点，找不到则返回null。 </code></p><p>注意：这两个方法有兼容性问题， IE9 以上才支持。 1 2 3 4 5 6 7 11.5.4 创建节点 document.createElement(&#39;tagName&#39;) <code>创建由 tagName 指定的 HTML 元素。因为这些元素原先不存在，是根据我们的需求动态生成的，所以我们也称为动态创建元素节点。</code></p><p>node.appendChild(child) <code>将一个节点添加到指定父节点的子节点列表末尾。类似于 CSS 里面的 after 伪元素。</code></p><p>node.insertBefore(child, 指定元素) <code>将一个节点添加到父节点的指定子节点前面。类似于 CSS 里面的 before 伪元素。</code> 1 2 3 4 5 6 7 8 11.5.5 删除节点 node.removeChild(child) 从 DOM 中删除一个子节点，返回删除的节点。</p><p>11.5.6 复制节点(克隆节点) node.cloneNode() 返回调用该方法的节点的一个副本。 也称为克隆节点/拷贝节点 如果括号参数为空或者为 false ，只克隆复制节点本身，不克隆里面的子节点。 如果括号参数为 true ，会复制节点本身以及里面所有的子节点。</p><p>11.5.7 三种动态创建元素区别 document.write() element.innerHTML document.createElement()</p><p>document.write 是直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致页面全部重绘 innerHTML 是将内容写入某个 DOM 节点，不会导致页面全部重绘 innerHTML 创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂 createElement() 创建多个元素效率稍低一点点，但是结构更清晰 总结：不同浏览器下，innerHTML 效率要比 creatElement 高</p><h1 id="十二-操作bom" tabindex="-1"><a class="header-anchor" href="#十二-操作bom" aria-hidden="true">#</a> 十二， 操作BOM</h1><h2 id="_12-1-bom概述" tabindex="-1"><a class="header-anchor" href="#_12-1-bom概述" aria-hidden="true">#</a> 12.1 BOM概述</h2><p>BOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window。</p><p>BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。</p><p>BOM 缺乏标准，JavaScript 语法的标准化组织是 ECMA，DOM 的标准化组织是 W3C，BOM 最初是Netscape 浏览器标准的一部分。</p><p>组成：</p><p>window 对象是浏览器的顶级对象，它具有双重角色。</p><p>它是 JS 访问浏览器窗口的一个接口。 它是一个全局对象。定义在全局作用域中的变量、函数都会变成 window 对象的属性和方法。 在调用的时候可以省略 window，对话框也属于 window 对象方法，如 alert()、prompt() 等。 注意：window下的一个特殊属性 window.name</p><h2 id="_12-2-window-对象的常见事件" tabindex="-1"><a class="header-anchor" href="#_12-2-window-对象的常见事件" aria-hidden="true">#</a> 12.2 window 对象的常见事件</h2><p>12.2.1 窗口加载事件 窗口 (页面）加载事件,当文档内容完全加载完成会触发该事件(包括图像、脚本文件、CSS 文件等), 就调用的处理函数。</p><p>window.onload = function(){} 或者 window.addEventListener(&quot;load&quot;,function(){}); 1 2 3 4 5 注意：</p><p>有了 window.onload 就可以把 JS 代码写到页面元素的上方，因为 onload 是等页面内容全部加载完毕，再去执行处理函数。 window.onload 传统注册事件方式 只能写一次，如果有多个，会以最后一个 window.onload 为准。 如果使用 addEventListener 则没有限制 document.addEventListener(&#39;DOMContentLoaded&#39;,function(){}) 1 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等。 Ie9以上才支持 如果页面的图片很多的话, 从用户访问到onload触发可能需要较长的时间, 交互效果就不能实现，必然影响用户的体验，此时用 DOMContentLoaded 事件比较合适。</p><p>12.2.2 调整窗口大小事件 window.onresize = function(){}</p><p>window.addEventListener(&quot;resize&quot;,function(){}); 1 2 3 注意：</p><p>只要窗口大小发生像素变化，就会触发这个事件。 经常利用这个事件完成响应式布局。 window.innerWidth 当前屏幕的宽度</p><h2 id="_12-3-定时器" tabindex="-1"><a class="header-anchor" href="#_12-3-定时器" aria-hidden="true">#</a> 12.3 定时器</h2><p>window 对象提供了 2 个非常好用的方法-定时器。</p><p>setTimeout() setInterval() 12.3.1 setTimeout() 定时器 window.setTimeout(调用函数, [延迟的毫秒数]); 1 window 可以省略。 延迟的毫秒数省略默认是 0，单位是毫秒。 因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。</p><p>12.3.2 停止 setTimeout() 定时器 //setInterval() 方法重复调用一个函数，每隔这个时间，就去调用一次回调函数。 window.clearTimeout(timeoutID) 1 2 clearTimeout()方法取消了先前通过调用 setTimeout() 建立的定时器。 里面的参数就是定时器的标识符 。</p><p>12.3.4 setInterval() 定时器 //setInterval() 方法重复调用一个函数，每隔这个时间，就去调用一次回调函数。 window.setInterval(回调函数, [间隔的毫秒数]); 1 2 window 可以省略。 延迟的毫秒数省略默认是 0，单位是毫秒。 因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。</p><p>12.3.5 停止setInterval() 定时器 window.clearInterval(intervalID); 1 clearInterval()方法取消了先前通过调用 setInterval()建立的定时器。 里面的参数就是定时器的标识符 。</p><h2 id="_12-4-js执行队列" tabindex="-1"><a class="header-anchor" href="#_12-4-js执行队列" aria-hidden="true">#</a> 12.4 JS执行队列</h2><h3 id="_12-4-1-js-是单线程" tabindex="-1"><a class="header-anchor" href="#_12-4-1-js-是单线程" aria-hidden="true">#</a> 12.4.1 JS 是单线程</h3><p>JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。这是因为 Javascript 这门脚本语言诞生的使命所致——JavaScript 是为处理页面中用户的交互，以及操作 DOM 而诞生的。比如我们对某个 DOM 元素进行添加和删除操作，不能同时进行。 应该先进行添加，之后再删除。</p><p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p><p>为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程。于是，JS 中出现了同步和异步。</p><p>同步任务: 同步任务都在主线程上执行，形成一个执行栈。</p><p>异步任务: JS 的异步是通过回调函数实现的。 一般而言，异步任务有以下三种类型:</p><p>普通事件，如 click、resize 等 资源加载，如 load、error 等 定时器，包括 setInterval、setTimeout 等 异步任务相关回调函数添加到任务队列中（任务队列也称为消息队列）。</p><h3 id="_12-4-2-js-执行机制" tabindex="-1"><a class="header-anchor" href="#_12-4-2-js-执行机制" aria-hidden="true">#</a> 12.4.2 JS 执行机制</h3><p>先执行执行栈中的同步任务。 异步任务（回调函数）放入任务队列中。 一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。</p><p>由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（ event loop）。</p><h2 id="_12-5-location-对象" tabindex="-1"><a class="header-anchor" href="#_12-5-location-对象" aria-hidden="true">#</a> 12.5 location 对象</h2><p>window 对象给我们提供了一个 location 属性用于获取或设置窗体的 URL，并且可以用于解析 URL 。 因为这个属性返回的是一个对象，所以我们将这个属性也称为 location 对象。</p><h3 id="_12-5-1-url" tabindex="-1"><a class="header-anchor" href="#_12-5-1-url" aria-hidden="true">#</a> 12.5.1 URL</h3><p>统一资源定位符 (Uniform Resource Locator, URL) 是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p><p>URL 的一般语法格式为：</p><p>protocol://host[:port]/path/[?query]#fragment</p><p>http://www.baidu.cn/index.html?name=zhangsan&amp;age=23#link 1 2 3</p><h3 id="_12-5-2-location-对象的属性" tabindex="-1"><a class="header-anchor" href="#_12-5-2-location-对象的属性" aria-hidden="true">#</a> 12.5.2 location 对象的属性</h3><h3 id="_12-5-3-location-对象的方法" tabindex="-1"><a class="header-anchor" href="#_12-5-3-location-对象的方法" aria-hidden="true">#</a> 12.5.3 location 对象的方法</h3><h2 id="_12-6-navigator-对象" tabindex="-1"><a class="header-anchor" href="#_12-6-navigator-对象" aria-hidden="true">#</a> 12.6 navigator 对象</h2><p>navigator 对象包含有关浏览器的信息，它有很多属性，我们最常用的是 userAgent，该属性可以返回由客户机发送服务器的 user-agent 头部的值。 下面前端代码可以判断用户那个终端打开页面，实现跳转</p><p>if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) { window.location.href = &quot;&quot;; //手机 } else { window.location.href = &quot;&quot;; //电脑 } 1 2 3 4 5</p><h2 id="_12-7-history-对象" tabindex="-1"><a class="header-anchor" href="#_12-7-history-对象" aria-hidden="true">#</a> 12.7 history 对象</h2><p>window 对象给我们提供了一个 history 对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的 URL。</p><h2 id="_12-8-本地存储" tabindex="-1"><a class="header-anchor" href="#_12-8-本地存储" aria-hidden="true">#</a> 12.8 本地存储</h2><p>随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，HTML5规范提出了相关解决方案。</p><p>本地存储特性：</p><p>数据存储在用户浏览器中 设置、读取方便、甚至页面刷新不丢失数据 容量较大，sessionStorage约5M、localStorage约20M 只能存储字符串，可以将对象JSON.stringify() 编码后存储</p><h3 id="_12-8-1-window-sessionstorage" tabindex="-1"><a class="header-anchor" href="#_12-8-1-window-sessionstorage" aria-hidden="true">#</a> 12.8.1 window.sessionStorage</h3><p>生命周期为关闭浏览器窗口 在同一个窗口(页面)下数据可以共享 以键值对的形式存储使用 12.8.1.1 存储数据 sessionStorage.setItem(key, value) 1 12.8.1.2 获取数据 sessionStorage.getItem(key) 1 12.8.1.3 删除数据 sessionStorage.removeItem(key) 1 12.8.1.4 删除所有数据 sessionStorage.clear() 1 12.8.1 window.localStorage 声明周期永久生效，除非手动删除 否则关闭页面也会存在 可以多窗口（页面）共享（同一浏览器可以共享） 以键值对的形式存储使用 12.8.1.1 存储数据 localStorage.setItem(key, value) 1 12.8.1.2 获取数据 localStorage.getItem(key) 1 12.8.1.3 删除数据 localStorage.removeItem(key) 1 12.8.1.4 删除所有数据 localStorage.clear() 1</p><h1 id="十三-js网页特效" tabindex="-1"><a class="header-anchor" href="#十三-js网页特效" aria-hidden="true">#</a> 十三，JS网页特效</h1><h2 id="_13-1-元素偏移量-offset" tabindex="-1"><a class="header-anchor" href="#_13-1-元素偏移量-offset" aria-hidden="true">#</a> 13.1 元素偏移量 offset</h2><p>offset 翻译过来就是偏移量， 我们使用 offset 系列相关属性可以动态的得到该元素的位置（偏移）、大小等。</p><p>获得元素距离带有定位父元素的位置 获得元素自身的大小（宽度高度）</p><p>注意： 返回的数值都不带单位</p><p>offset 与 style 区别</p><h2 id="_13-2-元素可视区-client" tabindex="-1"><a class="header-anchor" href="#_13-2-元素可视区-client" aria-hidden="true">#</a> 13.2 元素可视区 client</h2><p>client 翻译过来就是客户端，我们使用 client 系列的相关属性来获取元素可视区的相关信息。通过 client 系列的相关属性可以动态的得到该元素的边框大小、元素大小等。</p><h2 id="_13-3-元素滚动-scroll" tabindex="-1"><a class="header-anchor" href="#_13-3-元素滚动-scroll" aria-hidden="true">#</a> 13.3 元素滚动 scroll</h2><p>scroll 翻译过来就是滚动的，我们使用 scroll 系列的相关属性可以动态的得到该元素的大小、滚动距离等。</p><p>如果浏览器的高（或宽）度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏掉的高度，我们就称为页面被卷去的头部。滚动条在滚动时会触发 onscroll 事件。</p><p>注意：页面滚动的距离通过 window.pageXOffset 获得</p><h2 id="_13-4-动画函数封装" tabindex="-1"><a class="header-anchor" href="#_13-4-动画函数封装" aria-hidden="true">#</a> 13.4 动画函数封装</h2><h3 id="_13-4-1-动画实现原理" tabindex="-1"><a class="header-anchor" href="#_13-4-1-动画实现原理" aria-hidden="true">#</a> 13.4.1 动画实现原理</h3><p>核心原理：通过定时器 setInterval() 不断移动盒子位置。 实现步骤：</p><p>获得盒子当前位置 让盒子在当前位置加上1个移动距离 利用定时器不断重复这个操作 加一个结束定时器的条件 注意此元素需要添加定位，才能使用element.style.left</p><h3 id="_13-4-2-动画函数简单封装" tabindex="-1"><a class="header-anchor" href="#_13-4-2-动画函数简单封装" aria-hidden="true">#</a> 13.4.2 动画函数简单封装</h3><p>注意函数需要传递2个参数，动画对象和移动到的距离。</p><h3 id="_13-4-3-动画函数给不同元素记录不同定时器" tabindex="-1"><a class="header-anchor" href="#_13-4-3-动画函数给不同元素记录不同定时器" aria-hidden="true">#</a> 13.4.3 动画函数给不同元素记录不同定时器</h3><p>如果多个元素都使用这个动画函数，每次都要var 声明定时器。我们可以给不同的元素使用不同的定时器（自己专门用自己的定时器）。 核心原理：利用 JS 是一门动态语言，可以很方便的给当前对象添加属性。</p><h3 id="_13-4-4-缓动效果原理" tabindex="-1"><a class="header-anchor" href="#_13-4-4-缓动效果原理" aria-hidden="true">#</a> 13.4.4 缓动效果原理</h3><p>缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来 思路：</p><p>让盒子每次移动的距离慢慢变小，速度就会慢慢落下来。 核心算法： (目标值 - 现在的位置 ) / 10 做为每次移动的距离 步长 停止的条件是： 让当前盒子位置等于目标位置就停止定时器 注意步长值需要取整</p><h3 id="_13-4-5-动画函数多个目标值之间移动" tabindex="-1"><a class="header-anchor" href="#_13-4-5-动画函数多个目标值之间移动" aria-hidden="true">#</a> 13.4.5 动画函数多个目标值之间移动</h3><p>可以让动画函数从 800 移动到 500。 当我们点击按钮时候，判断步长是正值还是负值</p><p>如果是正值，则步长 往大了取整 如果是负值，则步长 向小了取整</p><h3 id="_13-4-6-动画函数添加回调函数" tabindex="-1"><a class="header-anchor" href="#_13-4-6-动画函数添加回调函数" aria-hidden="true">#</a> 13.4.6 动画函数添加回调函数</h3><p>回调函数原理：函数可以作为一个参数。将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数，这个过程就叫做回调。 回调函数写的位置：定时器结束的位置。</p><h3 id="_13-4-7-动画函数封装到单独js文件里面" tabindex="-1"><a class="header-anchor" href="#_13-4-7-动画函数封装到单独js文件里面" aria-hidden="true">#</a> 13.4.7 动画函数封装到单独JS文件里面</h3><p>因为以后经常使用这个动画函数，可以单独封装到一个JS文件里面，使用的时候引用这个JS文件即可。</p><p>单独新建一个JS文件。 HTML文件引入 JS 文件。</p><h2 id="_13-5-节流阀" tabindex="-1"><a class="header-anchor" href="#_13-5-节流阀" aria-hidden="true">#</a> 13.5 节流阀</h2><p>防止轮播图按钮连续点击造成播放过快。 节流阀目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。 核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数。 开始设置一个变量 var flag = true; If(flag) {flag = false; do something} 关闭水龙头 利用回调函数 动画执行完毕， flag = true 打开水龙头</p><h1 id="十四-js移动端" tabindex="-1"><a class="header-anchor" href="#十四-js移动端" aria-hidden="true">#</a> 十四，JS移动端</h1><h2 id="_14-1-触屏事件" tabindex="-1"><a class="header-anchor" href="#_14-1-触屏事件" aria-hidden="true">#</a> 14.1 触屏事件</h2><h3 id="_14-1-1-概述" tabindex="-1"><a class="header-anchor" href="#_14-1-1-概述" aria-hidden="true">#</a> 14.1.1 概述</h3><p>移动端浏览器兼容性较好，我们不需要考虑以前 JS 的兼容性问题，可以放心的使用原生 JS 书写效果，但是移动端也有自己独特的地方。比如触屏事件 touch（也称触摸事件），Android 和 IOS 都有。 touch 对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（或触控笔）对屏幕或者触控板操作。 常见的触屏事件如下：</p><h3 id="_14-1-2-触摸事件对象-touchevent" tabindex="-1"><a class="header-anchor" href="#_14-1-2-触摸事件对象-touchevent" aria-hidden="true">#</a> 14.1.2 触摸事件对象（TouchEvent）</h3><p>TouchEvent 是一类描述手指在触摸平面（触摸屏、触摸板等）的状态变化的事件。这类事件用于描述一个或多个触点，使开发者可以检测触点的移动，触点的增加和减少，等等 touchstart、touchmove、touchend 三个事件都会各自有事件对象。 触摸事件对象重点我们看三个常见对象列表：</p><h3 id="_14-1-3-移动端拖动元素" tabindex="-1"><a class="header-anchor" href="#_14-1-3-移动端拖动元素" aria-hidden="true">#</a> 14.1.3 移动端拖动元素</h3><p>touchstart、touchmove、touchend 可以实现拖动元素 但是拖动元素需要当前手指的坐标值 我们可以使用 targetTouches[0] 里面的pageX 和 pageY 移动端拖动的原理： 手指移动中，计算出手指移动的距离。然后用盒子原来的位置 + 手指移动的距离 手指移动的距离： 手指滑动中的位置 减去 手指刚开始触摸的位置 拖动元素三步曲： （1） 触摸元素 touchstart： 获取手指初始坐标，同时获得盒子原来的位置 （2） 移动手指 touchmove： 计算手指的滑动距离，并且移动盒子 （3） 离开手指 touchend: 注意： 手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动 e.preventDefault();</p><h2 id="_14-2-移动端常用开发插件" tabindex="-1"><a class="header-anchor" href="#_14-2-移动端常用开发插件" aria-hidden="true">#</a> 14.2 移动端常用开发插件</h2><p>移动端常见插件：iScroll、Swiper、SuperSlider 。</p><p>Swiper 插件： 中文官网地址： https://www.swiper.com.cn/</p><p>iScroll 插件： https://github.com/cubiq/iscroll</p><p>SuperSlider 插件： http://www.superslide2.com/</p><p>视频插件 zy.media.js: H5 给我们提供了 video 标签，但是浏览器的支持情况不同。在移动端我们可以使用插件方式来制作。</p><p>14.3 移动端click 延时解决方案 移动端 click 事件会有 300ms 的延时，原因是移动端屏幕双击会缩放(double tap to zoom) 页面。 3种解决方案：</p><p>禁用缩放。 浏览器禁用默认的双击缩放行为并且去掉 300ms 的点击延迟。</p><meta name="viewport" content="user-scalable=no">', 361);
const _hoisted_362 = /* @__PURE__ */ createBaseVNode(
  "p",
  null,
  [
    /* @__PURE__ */ createTextVNode("//封装tap，解决click 300ms 延时 function tap (obj, callback) { var isMove = false; var startTime = 0; // 记录触摸时候的时间变量 obj.addEventListener('touchstart', function (e) { startTime = Date.now(); // 记录触摸时间 }); obj.addEventListener('touchmove', function (e) { isMove = true; // 看看是否有滑动，有滑动算拖拽，不算点击 }); obj.addEventListener('touchend', function (e) { if (!isMove && (Date.now() - startTime) < 150) { // 如果手指触摸和离开时间小于150ms 算点击 callback && callback(); // 执行回调函数 } isMove = false; // 取反 重置 startTime = 0; }); } //调用"),
    /* @__PURE__ */ createBaseVNode("br"),
    /* @__PURE__ */ createTextVNode(" tap(div, function(){ // 执行代码 });")
  ],
  -1
  /* HOISTED */
);
const _hoisted_363 = /* @__PURE__ */ createBaseVNode(
  "p",
  null,
  "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 使用插件。 fastclick 插件解决 300ms 延迟。",
  -1
  /* HOISTED */
);
const _hoisted_364 = /* @__PURE__ */ createBaseVNode(
  "p",
  null,
  [
    /* @__PURE__ */ createTextVNode("document.addEventListener('DOMContentLoaded',function () { /"),
    /* @__PURE__ */ createBaseVNode("em", null, "等页面文档加载完成 不需要等所有的资源"),
    /* @__PURE__ */ createTextVNode("/ FastClick.attach(document.body); }); 1 2 3 4")
  ],
  -1
  /* HOISTED */
);
const _hoisted_365 = /* @__PURE__ */ createBaseVNode(
  "h2",
  {
    id: "_14-4-移动端常用开发框架",
    tabindex: "-1"
  },
  [
    /* @__PURE__ */ createBaseVNode("a", {
      class: "header-anchor",
      href: "#_14-4-移动端常用开发框架",
      "aria-hidden": "true"
    }, "#"),
    /* @__PURE__ */ createTextVNode(" 14.4 移动端常用开发框架")
  ],
  -1
  /* HOISTED */
);
const _hoisted_366 = /* @__PURE__ */ createBaseVNode(
  "p",
  null,
  "Bootstrap、Vue(UniApp、Vant)、Angular",
  -1
  /* HOISTED */
);
const _hoisted_367 = /* @__PURE__ */ createBaseVNode(
  "p",
  null,
  "MUI 原生UI前端框架: http://dev.dcloud.net.cn/mui/",
  -1
  /* HOISTED */
);
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("div", null, [
    _hoisted_1,
    createTextVNode(" 1 利用touch事件自己封装这个事件解决 300ms 延迟。 原理就是： 1） 当我们手指触摸屏幕，记录当前触摸时间 2） 当我们手指离开屏幕， 用离开的时间减去触摸的时间 3） 如果时间小于150ms，并且没有滑动过屏幕， 那么我们就定义为点击 "),
    _hoisted_362,
    _hoisted_363,
    _hoisted_364,
    _hoisted_365,
    _hoisted_366,
    _hoisted_367
  ]);
}
const JSwanzhengxuexibiji_html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "JSwanzhengxuexibiji.html.vue"]]);
export {
  JSwanzhengxuexibiji_html as default
};
