import { _ as _export_sfc, o as openBlock, c as createElementBlock, d as createStaticVNode } from "./app-030547e9.js";
const _imports_0 = "/bowenBlog/assets/image-20240129172638852-142d17e4.png";
const _sfc_main = {};
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<hr><h2 id="重点知识点" tabindex="-1"><a class="header-anchor" href="#重点知识点" aria-hidden="true">#</a> 重点知识点</h2><h2 id="一-事件循环" tabindex="-1"><a class="header-anchor" href="#一-事件循环" aria-hidden="true">#</a> 一, 事件循环</h2><hr><h3 id="_1-浏览器的进程模型" tabindex="-1"><a class="header-anchor" href="#_1-浏览器的进程模型" aria-hidden="true">#</a> 1, 浏览器的进程模型</h3><h4 id="什么是进程" tabindex="-1"><a class="header-anchor" href="#什么是进程" aria-hidden="true">#</a> 什么是进程?</h4><p>程序运行需要有它专属的内存空间, 那么这个内存空间可以简单的理解为进程;</p><p><strong>程序的独立性(隔离)</strong></p><p>每个应用至少有一个进程, 进程之间相互独立, 即使要通信, 也需要双方同意</p><h4 id="什么是线程" tabindex="-1"><a class="header-anchor" href="#什么是线程" aria-hidden="true">#</a> 什么是线程?</h4><p>有了进程之后, 就可以运行代码</p><p>运行代码的<code>人</code>, 可以称为<code>线程</code>;</p><p>一个进程至少有一个线程, 所以进程开启后会自动创建一个线程来运行代码, 该线程称为<code>主线程</code></p><h4 id="浏览器有哪些进程和线程" tabindex="-1"><a class="header-anchor" href="#浏览器有哪些进程和线程" aria-hidden="true">#</a> 浏览器有哪些进程和线程</h4><p><strong>浏览器是一个多进程多线程的应用程序</strong></p><p>浏览器内部工作极其复杂</p><p>为了避免相互影响, 为了减少连环崩溃的几率, 当启动浏览器的时候, 他会启动多个进程</p><p>我们关心的三个进程:</p><ol><li>浏览器进程 <ul><li>主要负责界面显示 用户交互 子进程管理等; 浏览器进程内部会启动多个线程处理不同的任务</li></ul></li><li>网络进程 <ul><li>负责加载网络资源, 网络进程内部会启动多个线程来处理不同的网络任务</li></ul></li><li>渲染进程 (重点) <ul><li>渲染进程启动后, 会开启一个<code>渲染主线程</code> , 主线程负责执行 HTML CSS JS 代码</li><li>默认情况下, 浏览器会为每个标签页开启一个新的渲染进程, 以保证不同的页面之间不会相互影响 * (<em>将来这种模式可以能会改变</em>)</li></ul></li></ol><h3 id="_2-浏览器的主线程是如何工作的" tabindex="-1"><a class="header-anchor" href="#_2-浏览器的主线程是如何工作的" aria-hidden="true">#</a> 2, 浏览器的主线程是如何工作的</h3><p>渲染主线程是浏览器中最繁忙的线程, 需要它处理的任务包括但是不限于:</p><ul><li>解析 HTML</li><li>解析 CSS</li><li>计算样式</li><li>布局</li><li>处理图层</li><li>每秒的 60 帧 画面刷新</li><li>执行事件处理函数</li><li>执行计时器的回调函数</li><li>...</li></ul><blockquote><p>为什么渲染进程不适用多个线程来处理这些事情</p></blockquote><p>要处理这么多的任务, 主线程遇到了一个前所未有的难题, 如何调度任务?</p><p>渲染主线程想出来一个办法来处理这个问题 : 排队</p><p>也就是我们的<strong>消息队列</strong></p><p>渲染主线程</p><p>消息队列 (message queue)</p><blockquote><p>事件循环 ( events loop )</p><p>也称为消息循环 (message loop)</p></blockquote><ol><li>在最开始的时候, 渲染主线程会进入一个无线循环 (在源码中我们可以看到执行了一个 for( ;; ) )</li><li>每一次循环会检查消息队列中是否有任务存在; 如果有, 就取出第一个任务执行, 执行完一个后进入下一次循环, 如果没有, 则进入<strong>休眠状态</strong></li><li>其他所有线程, (包括其他进程的线程) 可以随时向消息队列添加任务; 新任务会加到消息队列的末尾; 在添加新任务时, 如果主线程是休眠状态, 则会将其唤醒以继续循环拿取任务</li></ol><p>这样一来, 就可以让每个人物有条理, 持续的执行下去</p><p>整个过程, 被称为<strong>事件循环 (消息循环)</strong></p><h3 id="_3-其他引出知识点解释" tabindex="-1"><a class="header-anchor" href="#_3-其他引出知识点解释" aria-hidden="true">#</a> 3, 其他引出知识点解释</h3><h4 id="什么是异步" tabindex="-1"><a class="header-anchor" href="#什么是异步" aria-hidden="true">#</a> 什么是异步?</h4><p>代码执行的过程中, 会遇到一些无法立即处理的任务, 比如</p><ul><li>计时完成后需要执行的任务</li><li>网络通信完成后需要执行的任务</li><li>用户操作后需要执行的任务</li></ul><p>如果让渲染主线程等待这些任务的时机到达, 就会导致主线程长期处于 <code>阻塞</code> 的状态, 从而导致浏览器<code>卡死</code></p><blockquote><p>渲染主线程承担着极其重要的工作, 无论如何都不能阻塞, 因此浏览器选择<code>异步</code>来解决这个问题</p></blockquote><p>使用异步的方式, <strong>渲染主线程永不阻塞</strong></p><h4 id="面试题-如何理解-js-的异步" tabindex="-1"><a class="header-anchor" href="#面试题-如何理解-js-的异步" aria-hidden="true">#</a> 面试题: 如何理解 JS 的异步?</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>JS是一门单线程的语言, 这是因为它运行在浏览器的渲染主线程中, 而渲染主线程只有一个; \n而渲染主线程承担着大量的工作, 比如渲染页面 执行 JS等...\n\n如果使用同步的方式, 就有可能导致主线程执行的阻塞, 从而从消息队列中的很多其他任务无法得到执行, 这样一来,一方面会导致繁忙的主线程白白浪费时间, 另一方面导致页面无法及时更新, 给用户 造成卡死的现象; \n\n所以浏览器采用异步的方式来避免; 具体做法是当某些任务发生时, 比如计时器, 网络, 事件监听, 主线程将任务交给其他线程去处理, 自身立即处理结束任务的执行, 转而执行后续代码; 当其他线程完成后, 将事先传递的回调函数包装成任务, 加入到消息队列的末尾队列, 等待主线程调度执行;\n\n在这种异步模式下, 浏览器永不阻塞(不会因为某个任务而阻塞整个页面), 从而最大限度的保证了单线程的流畅运行;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="js为何会阻塞渲染" tabindex="-1"><a class="header-anchor" href="#js为何会阻塞渲染" aria-hidden="true">#</a> JS为何会阻塞渲染?</h4><p>JavaScript是单线程执行的。</p><p>也就是说，JavaScript引擎只有一个线程，而且在执行JavaScript代码时，会阻塞页面的UI渲染和响应事件。</p><p>阻塞操作举例：</p><ul><li>大量的计算操作</li><li>长时间的循环操作</li><li>同步的ajax请求</li><li>大量的dom操作</li><li>...</li></ul><h4 id="任务有优先级吗" tabindex="-1"><a class="header-anchor" href="#任务有优先级吗" aria-hidden="true">#</a> 任务有优先级吗?</h4><p>任务没有优先级, 在消息队列中先进先出</p><p>但是消息队列是有优先级的</p><ol><li>每个任务都有一个任务类型, 同一个类型的任务必须在一个队列, 不同类型的任务可以分属于不同的队列; 在一个事件循环中, 浏览器可以根据实际情况从不同的队列中取出任务执行</li><li>浏览器必须准备好一个微队列, 微队列中的任务优先所有其他任务执行</li></ol><blockquote><p>随着浏览器的复杂度急剧提升, w3c不再使用宏队列的说法</p></blockquote><p>在目前的 chrome 的实现中, 至少包含了下面的队列:</p><ol><li>延时队列: 用于存放计时器到达后的回调任务 (优先级 中)</li><li>交互队列: 用于存放用户操作后产生的事件处理任务 (优先级 高)</li><li>微队列: 用户存放需要最快执行的任务 (优先级 最高)</li></ol><blockquote><p><strong>渲染主线程</strong> -- 全局</p><blockquote><p>微队列</p><p>延时队列</p><p>交互队列</p></blockquote><p>其他线程...</p></blockquote><p>​</p><h4 id="面试题-说一下-js-的事件循环" tabindex="-1"><a class="header-anchor" href="#面试题-说一下-js-的事件循环" aria-hidden="true">#</a> 面试题 : 说一下 JS 的事件循环</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>\n在 chrome 的源码中, 它开启一个不会结束的 for 循环, 每次循环从消息队列中取出第一个任务执行,而其他线程只需要在合适的时候将任务加入到队列末尾即可, \n\n过去把消息队列分为宏队列和微队列, 这种说法已经无法满足复杂的浏览器环境, 取而代之的是一种更加灵活多变的处理方式;\n\n根据 W3C 官方的解释, 每个任务有不同的类型, 同类型的任务必须在同一个队列, 不同的任务可以属于不同的队列, 不同任务队列有不同的优先级, 在一次事件循环中, 由浏览器自行决定取哪一个队列的任务, 但是浏览器必须有一个微队列, 微队列的任务一定具有最高的优先级, 必须优先调度执行;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用户交互的事件 ( 浏览器默认认为优先级最高 , 注重用户的体验)</p><h4 id="面试题-js中的计时器能做到精准计时吗-为什么" tabindex="-1"><a class="header-anchor" href="#面试题-js中的计时器能做到精准计时吗-为什么" aria-hidden="true">#</a> 面试题: JS中的计时器能做到精准计时吗? 为什么</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>不行\n1. 计算机硬件中没有原子钟, 无法做到精准计时 (?)\n2. 操作系统的计时函数本身就有少量的偏差, 由于JS的计时器最终调用的是操作系统的函数, 也就携带了这些偏差\n3. 按照W3C的标准, 浏览器实现计时器时, 如果嵌套层级超过了5层 (level 5 ) , 则会带有4毫秒的最少时间, 这样在计时时间少于4ms时又带来了偏差\n4. 受到事件循环的影响, 计时器的回调函数只能在主线程空闲时运行, 因此又带来了偏差\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="二-浏览器渲染原理" tabindex="-1"><a class="header-anchor" href="#二-浏览器渲染原理" aria-hidden="true">#</a> 二, 浏览器渲染原理</h2><p><strong>渲染</strong></p><p>render</p><p>html字符串 -- (经过复杂的计算操作工序) -&gt; 像素信息</p><p><strong>渲染时间点</strong></p><p>网络 : 获取HTML</p><p>渲染 : 渲染</p><p>网络进程</p><h3 id="_1-浏览器是如何渲染页面的" tabindex="-1"><a class="header-anchor" href="#_1-浏览器是如何渲染页面的" aria-hidden="true">#</a> 1, 浏览器是如何渲染页面的?</h3><p>当浏览器的网络线程收到 HTML 文档后, 会产生一个<code>渲染任务</code>, 并将其传递给渲染主线程的消息队列;</p><p>在事件循环的机制的作用下, 渲染主线程取出消息队列中的渲染任务, 开启渲染流程;</p><p>整个渲染流程分为多个阶段: HTML解析, 样式计算, ...</p><p><strong>渲染流水线</strong></p><p><img src="' + _imports_0 + '" alt="image-20240129172638852"></p><ol><li>解析HTML - ParseHTML</li></ol><ul><li>DOM树</li><li>CSSOM树 <ul><li>生成CSS样式表 <ul><li>内部样式表</li><li>外部样式表</li><li>行内样式表</li><li>浏览器默认样式表 (css的规则会生成一个规则对象)</li><li>....</li></ul></li></ul></li></ul><p>github Repositories 插件</p><p>目前的 chrome 浏览器的内核是 blink 内核</p><blockquote><p>Blink 是一个开源的浏览器渲染引擎，最初由Google开发，并且在Chrome浏览器中使用。它是WebKit渲染引擎的一个分支，于2013年发布并逐渐取代了WebKit作为Chrome浏览器的默认渲染引擎。</p><p>Blink的设计目标是提供更快、更稳定、更安全的网页渲染体验。它采用多进程的架构，将不同的任务分配给不同的进程，从而实现更高的并行性和响应速度。例如，<strong>Blink将网络请求、JavaScript解析、布局计算等任务分别处理，避免了单个任务阻塞整个页面的问题。</strong></p><p>内核特点:</p><ol><li>高性能</li><li>标准支持</li><li>安全性</li></ol></blockquote><p>document.styleSheets 通过JS去操作样式表</p><h4 id="html解析的过程中遇到-css-代码怎么办" tabindex="-1"><a class="header-anchor" href="#html解析的过程中遇到-css-代码怎么办" aria-hidden="true">#</a> HTML解析的过程中遇到 CSS 代码怎么办 ?</h4><p>为了提高解析效率, 浏览器会启动一个预解析器率先下载和解析CSS</p><p>执行步骤:</p><ol><li>渲染</li><li>样式计算</li><li>布局</li><li>分层</li><li>绘制</li><li>分块</li><li>光栅化</li><li>画</li></ol><h2 id="面试题" tabindex="-1"><a class="header-anchor" href="#面试题" aria-hidden="true">#</a> 面试题</h2><h3 id="浏览器是如何渲染页面的" tabindex="-1"><a class="header-anchor" href="#浏览器是如何渲染页面的" aria-hidden="true">#</a> 浏览器是如何渲染页面的？</h3><p>当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。</p><p>在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。</p><hr><p>整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画</p><p>每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。</p><p>这样，整个渲染流程就形成了一套组织严密的生产流水线。</p><hr><p>渲染的第一步是<strong>解析 HTML</strong>。</p><p>解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。</p><p>如果主线程解析到<code>link</code>位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。</p><p>如果主线程解析到<code>script</code>位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。</p><p>第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。</p><hr><p>渲染的下一步是<strong>样式计算</strong>。</p><p>主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。</p><p>在这一过程中，很多预设值会变成绝对值，比如<code>red</code>会变成<code>rgb(255,0,0)</code>；相对单位会变成绝对单位，比如<code>em</code>会变成<code>px</code></p><p>这一步完成后，会得到一棵带有样式的 DOM 树。</p><hr><p>接下来是<strong>布局</strong>，布局完成后会得到布局树。</p><p>布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。</p><p>大部分时候，DOM 树和布局树并非一一对应。</p><p>比如<code>display:none</code>的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。</p><hr><p>下一步是<strong>分层</strong></p><p>主线程会使用一套复杂的策略对整个布局树中进行分层。</p><p>分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。</p><p>滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过<code>will-change</code>属性更大程度的影响分层结果。</p><hr><p>再下一步是<strong>绘制</strong></p><p>主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。</p><hr><p>完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。</p><p>合成线程首先对每个图层进行分块，将其划分为更多的小区域。</p><p>它会从线程池中拿取多个线程来完成分块工作。</p><hr><p>分块完成后，进入<strong>光栅化</strong>阶段。</p><p>合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。</p><p>GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。</p><p>光栅化的结果，就是一块一块的位图</p><hr><p>最后一个阶段就是<strong>画</strong>了</p><p>合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。</p><p>指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。</p><p>变形发生在合成线程，与渲染主线程无关，这就是<code>transform</code>效率高的本质原因。</p><p>合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。</p><h3 id="什么是-reflow-回流" tabindex="-1"><a class="header-anchor" href="#什么是-reflow-回流" aria-hidden="true">#</a> 什么是 reflow (回流) ？</h3><p>reflow 的本质就是重新计算 layout 树。</p><p>当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。</p><p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。</p><p>也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。</p><p>浏览器在反复权衡下，最终决定获取属性立即 reflow。</p><h3 id="什么是-repaint-重绘" tabindex="-1"><a class="header-anchor" href="#什么是-repaint-重绘" aria-hidden="true">#</a> 什么是 repaint (重绘)？</h3><p>repaint 的本质就是重新根据分层信息计算了绘制指令。</p><p>当改动了可见样式后，就需要重新计算，会引发 repaint。</p><p>由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。</p><h3 id="为什么-transform-的效率高" tabindex="-1"><a class="header-anchor" href="#为什么-transform-的效率高" aria-hidden="true">#</a> 为什么 transform 的效率高？</h3><p>因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段</p><p>由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。</p><h2 id="css-之包含块" tabindex="-1"><a class="header-anchor" href="#css-之包含块" aria-hidden="true">#</a> CSS 之包含块</h2><hr><p>一说到 CSS 盒模型，这是很多小伙伴耳熟能详的知识，甚至有的小伙伴还能说出 border-box 和 content-box 这两种盒模型的区别。</p><p>但是一说到 CSS 包含块，有的小伙伴就懵圈了，什么是包含块？好像从来没有听说过这玩意儿。</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-142005.png" alt="image-20220814222004395" style="zoom:20%;"><p>好吧，如果你对包含块的知识一无所知，那么系好安全带，咱们准备出发了。</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-060434.png" alt="image-20220813140434032" style="zoom:50%;"><p>包含块英语全称为<strong>containing block</strong>，实际上平时你在书写 CSS 时，大多数情况下你是感受不到它的存在，因此你不知道这个知识点也是一件很正常的事情。但是这玩意儿是确确实实存在的，在 CSS 规范中也是明确书写了的：</p><p><em>https://drafts.csswg.org/css2/#containing-block-details</em></p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-142459.png" alt="image-20220814222458695" style="zoom:50%;"><p>并且，如果你不了解它的运作机制，有时就会出现一些你认为的莫名其妙的现象。</p><p>那么，这个包含块究竟说了什么内容呢？</p><p>说起来也简单，<strong>就是元素的尺寸和位置，会受它的包含块所影响。对于一些属性，例如 width, height, padding, margin，绝对定位元素的偏移值（比如 position 被设置为 absolute 或 fixed），当我们对其赋予百分比值时，这些值的计算值，就是通过元素的包含块计算得来。</strong></p><p>来吧，少年，让我们从最简单的 case 开始看。</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-143153.png" alt="image-20220814223152726" style="zoom:50%;"><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>container<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code><span class="token selector">.container</span><span class="token punctuation">{</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> skyblue<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">.item</span><span class="token punctuation">{</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请仔细阅读上面的代码，然后你认为 div.item 这个盒子的宽高是多少？</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-143451.png" alt="image-20220814223451349" style="zoom:33%;"><p>相信你能够很自信的回答这个简单的问题，div.item 盒子的 width 为 250px，height 为 150px。</p><p>这个答案确实是没有问题的，但是如果我追问你是怎么得到这个答案的，我猜不了解包含块的你大概率会说，因为它的父元素 div.container 的 width 为 500px，50% 就是 250px，height 为 300px，因此 50% 就是 150px。</p><p>这个答案实际上是不准确的。正确的答案应该是，<strong>div.item 的宽高是根据它的包含块来计算的</strong>，而这里包含块的大小，正是这个元素最近的祖先块元素的内容区。</p><p>因此正如我前面所说，<strong>很多时候你都感受不到包含块的存在。</strong></p><p>包含块分为两种，一种是根元素（HTML 元素）所在的包含块，被称之为<code>初始包含块</code>（<strong>initial containing block</strong>）。对于浏览器而言，初始包含块的的大小等于视口 viewport 的大小，基点在画布的原点（视口左上角）。它是作为元素绝对定位和固定定位的参照物。</p><p>另外一种是对于非根元素，对于非根元素的包含块判定就有几种不同的情况了。大致可以分为如下几种：</p><ul><li>如果元素的 positiion 是 relative 或 static ，那么包含块由离它最近的块容器（block container）的内容区域（content area）的边缘建立。</li><li>如果 position 属性是 fixed，那么包含块由视口建立。</li><li>如果元素使用了 absolute 定位，则包含块由它的最近的 position 的值不是 static （也就是值为fixed、absolute、relative 或 sticky）的祖先元素的内边距区的边缘组成。</li></ul><p>前面两条实际上都还比较好理解，第三条往往是初学者容易比较忽视的，我们来看一个示例：</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>container<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item2<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> skyblue<span class="token punctuation">;</span>\n  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">.item</span> <span class="token punctuation">{</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 150px<span class="token punctuation">;</span>\n  <span class="token property">border</span><span class="token punctuation">:</span> 5px solid<span class="token punctuation">;</span>\n  <span class="token property">margin-left</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">.item2</span> <span class="token punctuation">{</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>\n  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>\n  <span class="token property">left</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>\n  <span class="token property">top</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先阅读上面的代码，然后你能在脑海里面想出其大致的样子么？或者用笔和纸画一下也行。</p><p>公布正确答案：</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-153548.png" alt="image-20220814233548188" style="zoom:33%;"><p>怎么样？有没有和你所想象的对上？</p><p>其实原因也非常简单，根据上面的第三条规则，对于 div.item2 来讲，它的包含块应该是 div.container，而非 div.item。</p><p>如果你能把上面非根元素的包含块判定规则掌握，那么关于包含块的知识你就已经掌握 80% 了。</p><p>实际上对于非根元素来讲，包含块还有一种可能，那就是如果 position 属性是 absolute 或 fixed，包含块也可能是由满足以下条件的最近父级元素的内边距区的边缘组成的：</p><ul><li>transform 或 perspective 的值不是 none</li><li>will-change 的值是 transform 或 perspective</li><li>filter 的值不是 none 或 will-change 的值是 filter(只在 Firefox 下生效).</li><li>contain 的值是 paint (例如: contain: paint;)</li></ul><p>我们还是来看一个示例：</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>container<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item2<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> skyblue<span class="token punctuation">;</span>\n  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">.item</span> <span class="token punctuation">{</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 150px<span class="token punctuation">;</span>\n  <span class="token property">border</span><span class="token punctuation">:</span> 5px solid<span class="token punctuation">;</span>\n  <span class="token property">margin-left</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>\n  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">rotate</span><span class="token punctuation">(</span>0deg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 新增代码 */</span>\n<span class="token punctuation">}</span>\n<span class="token selector">.item2</span> <span class="token punctuation">{</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>\n  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>\n  <span class="token property">left</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>\n  <span class="token property">top</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们对于上面的代码只新增了一条声明，那就是 transform: rotate(0deg)，此时的渲染效果却发生了改变，如下图所示：</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-154347.png" alt="image-20220814234347149" style="zoom:33%;"><p>可以看到，此时对于 div.item2 来讲，包含块就变成了 div.item。</p><p>好了，到这里，关于包含块的知识就基本讲完了。</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-154655.png" alt="image-20220814234654914" style="zoom:33%;"><p>我们再把 CSS 规范中所举的例子来看一下。</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Illustration of containing blocks<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>body<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>div1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>p1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>This is text in the first paragraph...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>p2<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>\n        This is text\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>em</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>em1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>\n          in the\n          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strong</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>strong1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>second<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>strong</span><span class="token punctuation">&gt;</span></span>\n          paragraph.\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>em</span><span class="token punctuation">&gt;</span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是一段简单的 HTML 代码，在没有添加任何 CSS 代码的情况下，你能说出各自的包含块么？</p><p>对应的结果如下：</p><table><thead><tr><th>元素</th><th>包含块</th></tr></thead><tbody><tr><td>html</td><td>initial C.B. (UA-dependent)</td></tr><tr><td>body</td><td>html</td></tr><tr><td>div1</td><td>body</td></tr><tr><td>p1</td><td>div1</td></tr><tr><td>p2</td><td>div1</td></tr><tr><td>em1</td><td>p2</td></tr><tr><td>strong1</td><td>p2</td></tr></tbody></table><p>首先 HTML 作为根元素，对应的包含块就是前面我们所说的初始包含块，而对于 body 而言，这是一个 static 定位的元素，因此该元素的包含块参照第一条为 html，以此类推 div1、p1、p2 以及 em1 的包含块也都是它们的父元素。</p><p>不过 strong1 比较例外，它的包含块确实 p2，而非 em1。为什么会这样？建议你再把非根元素的第一条规则读一下：</p><ul><li>如果元素的 positiion 是 relative 或 static ，那么包含块由离它最近的**块容器（block container）**的内容区域（content area）的边缘建立。</li></ul><p>没错，因为 em1 不是块容器，而包含块是<strong>离它最近的块容器</strong>的内容区域，所以是 p2。</p><p>接下来添加如下的 CSS：</p><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code><span class="token selector">#div1</span> <span class="token punctuation">{</span> \n  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span> \n  <span class="token property">left</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span> <span class="token property">top</span><span class="token punctuation">:</span> 50px \n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码我们对 div1 进行了定位，那么此时的包含块会发生变化么？你可以先在自己思考一下。</p><p>答案如下：</p><table><thead><tr><th>元素</th><th>包含块</th></tr></thead><tbody><tr><td>html</td><td>initial C.B. (UA-dependent)</td></tr><tr><td>body</td><td>html</td></tr><tr><td>div1</td><td>initial C.B. (UA-dependent)</td></tr><tr><td>p1</td><td>div1</td></tr><tr><td>p2</td><td>div1</td></tr><tr><td>em1</td><td>p2</td></tr><tr><td>strong1</td><td>p2</td></tr></tbody></table><p>可以看到，这里 div1 的包含块就发生了变化，变为了初始包含块。这里你可以参考前文中的这两句话：</p><ul><li>初始包含块（<strong>initial containing block</strong>）。对于浏览器而言，初始包含块的的大小等于视口 viewport 的大小，基点在画布的原点（视口左上角）。它是作为元素绝对定位和固定定位的参照物。</li><li>如果元素使用了 absolute 定位，则包含块由它的最近的 position 的值不是 static （也就是值为fixed、absolute、relative 或 sticky）的祖先元素的内边距区的边缘组成。</li></ul><p>是不是一下子就理解了。没错，因为我们对 div1 进行了定位，因此它会应用非根元素包含块计算规则的第三条规则，寻找离它最近的 position 的值不是 static 的祖先元素，不过显然 body 的定位方式为 static，因此 div1 的包含块最终就变成了初始包含块。</p><p>接下来我们继续修改我们的 CSS：</p><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code><span class="token selector">#div1</span> <span class="token punctuation">{</span> \n  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span> \n  <span class="token property">left</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span> \n  <span class="token property">top</span><span class="token punctuation">:</span> 50px \n<span class="token punctuation">}</span>\n<span class="token selector">#em1</span>  <span class="token punctuation">{</span> \n  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span> \n  <span class="token property">left</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span> \n  <span class="token property">top</span><span class="token punctuation">:</span> 100px \n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们对 em1 同样进行了 absolute 绝对定位，你想一想会有什么样的变化？</p><p>没错，聪明的你大概应该知道，em1 的包含块不再是 p2，而变成了 div1，而 strong1 的包含块也不再是 p2 了，而是变成了 em1。</p><p>如下表所示：</p><table><thead><tr><th>元素</th><th>包含块</th></tr></thead><tbody><tr><td>html</td><td>initial C.B. (UA-dependent)</td></tr><tr><td>body</td><td>html</td></tr><tr><td>div1</td><td>initial C.B. (UA-dependent)</td></tr><tr><td>p1</td><td>div1</td></tr><tr><td>p2</td><td>div1</td></tr><tr><td>em1</td><td>div1（因为定位了，参阅非根元素包含块确定规则的第三条）</td></tr><tr><td>strong1</td><td>em1（因为 em1 变为了块容器，参阅非根元素包含块确定规则的第一条）</td></tr></tbody></table><p>好了，这就是 CSS 规范中所举的例子。如果你全都能看明白，以后你还能跟别人说你是看过这一块知识对应的 CSS 规范的人。</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-15-013519.png" alt="image-20220815093518833" style="zoom:33%;"><p>另外，关于包含块的知识，在 MDN 上除了解说了什么是包含块以外，也举出了很多简单易懂的示例。</p><p>具体你可以移步到：<em>https://developer.mozilla.org/zh-CN/docs/Web/CSS/Containing_block</em></p><p>好了，这就是有关包含块的所有内容了，你学会了么？</p><h2 id="三-属性描述符" tabindex="-1"><a class="header-anchor" href="#三-属性描述符" aria-hidden="true">#</a> 三, 属性描述符</h2><p>代码演示</p><p><strong>获取属性</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token string">&#39;1&#39;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 得到属性描述符</span>\n<span class="token keyword">const</span> res <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token comment">// { value: &#39;1&#39;, writable: true, enumerable: true, configurable: true }</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>设置属性</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token string">&#39;1&#39;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 获取属性描述符</span>\n<span class="token keyword">const</span> res <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>\n\n<span class="token comment">// 定义属性描述符</span>\nObject<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token comment">// 修改值</span>\n  <span class="token literal-property property">writable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token comment">// 不可重写</span>\n  <span class="token literal-property property">enumerable</span><span class="token operator">:</span> <span class="token boolean">false</span> <span class="token comment">// 不可遍历</span>\n  <span class="token comment">// configurable: false // 属性描述符不能修改</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>a<span class="token punctuation">)</span>  <span class="token comment">// 10</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>get 和 set 方法 (getter 和 setter)</strong></p><ul><li>读取器</li><li>设置器</li></ul><p>设计程序的思想, 就是考虑程序的多种无法想到的情况</p><blockquote><p><code>属性描述符</code>是一个包含属性特性的对象，它可以用来描述一个对象的属性的行为。在 <strong>ES5</strong> 及之后的版本中，引入了 <code>Object.defineProperty</code> 和 <code>Object.defineProperties</code> 方法，用于创建属性描述符。</p></blockquote><p>属性描述符通常包括以下几个属性：</p><ol><li>configurable：表示属性是否可以被删除或者是否可以再次修改特性。如果设置为 true，则属性的特性（除了 writable）可以被改变，并且属性也可以被从对象上删除。默认为 false。</li><li>enumerable：表示属性是否可以被枚举。如果设置为 true，则属性可以出现在对象的枚举属性中。默认为 false。</li><li>value：属性的值。可以是任何有效的 JavaScript 值。默认为 undefined。</li><li>writable：表示属性的值是否可以被修改。如果设置为 true，则属性的值可以被赋值运算符改变。默认为 false。</li><li>get：一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。当访问该属性时，会调用此方法。该方法的返回值将作为属性的值。默认为 undefined。</li><li>set：一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值被修改时，会调用此方法。默认为 undefined。</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n\nObject<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">&#39;name&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token string">&#39;Alice&#39;</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">writable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">enumerable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">configurable</span><span class="token operator">:</span> <span class="token boolean">true</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>防止属性被修改, 我们使用 Object.freeze() 函数去冻结这个对象或属性... 如果修改原型的属性, 也可以去冻结原型... *( 思考不同的情况下问题的解决方法)</p><h2 id="四-手撕-vue" tabindex="-1"><a class="header-anchor" href="#四-手撕-vue" aria-hidden="true">#</a> 四, 手撕 Vue</h2><h3 id="_1-展示-vue" tabindex="-1"><a class="header-anchor" href="#_1-展示-vue" aria-hidden="true">#</a> 1, 展示 Vue</h3><p>创建 Vue 的实例 ( 面向对象的思想 )</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token comment">// 配置对象</span>\n  <span class="token literal-property property">el</span><span class="token operator">:</span> <span class="token string">&#39;css选择器&#39;</span><span class="token punctuation">,</span> \n  <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 界面数据</span>\n    <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">&#39;手机&#39;</span> <span class="token punctuation">,</span>\n    <span class="token literal-property property">goods</span><span class="token operator">:</span> goods\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>数据响应式 ( 数据驱动视图 )</p><blockquote><p>数据的变化引发视图的自动更新</p></blockquote><h3 id="_2-开发者思维" tabindex="-1"><a class="header-anchor" href="#_2-开发者思维" aria-hidden="true">#</a> 2, 开发者思维</h3><p>依赖收集</p><p>派发更新</p><p>数据响应式本质是在数据发生变化时, 内部会自动运行一些相关的函数 (引出) , 来驱动视图的更新</p>', 241);
const _hoisted_242 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("div", null, _hoisted_242);
}
const qianduanJinjiekecheng_duyi__html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "qianduan-jinjiekecheng(duyi).html.vue"]]);
export {
  qianduanJinjiekecheng_duyi__html as default
};
